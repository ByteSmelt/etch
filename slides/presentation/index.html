<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Etch - Define once, Etch forever</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/black.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">

		<style>
			/* Global reset and base styles */
			.reveal h1, .reveal h2, .reveal h3 {
				text-transform: none;
			}

			/* Heading sizes - reduced for better fit */
			.reveal h1 {
				font-size: 1.8em;
				margin-bottom: 0.3em;
				line-height: 1.1;
			}
			.reveal h2 {
				font-size: 1.3em;
				margin-bottom: 0.3em;
				line-height: 1.2;
			}
			.reveal h3 {
				font-size: 1.1em;
				margin-bottom: 0.25em;
				line-height: 1.2;
			}

			/* Body text and lists - smaller and tighter */
			.reveal p, .reveal li {
				font-size: 0.7em;
				line-height: 1.35;
				margin-bottom: 0.4em;
			}
			.reveal ul, .reveal ol {
				margin-top: 0.4em;
				margin-bottom: 0.4em;
			}
			.reveal li {
				margin-bottom: 0.3em;
			}

			/* Strong text - ensure it's visible but not huge */
			.reveal strong {
				font-weight: bold;
			}

			/* Images */
			.reveal section img {
				border: none;
				box-shadow: none;
				background: none;
			}

			/* Color accents */
			.reveal .checkmark {
				color: #00FF00;
			}
			.reveal .xmark {
				color: #FF6B6B;
			}
			.reveal .accent {
				color: #64FFDA;
			}

			/* Code blocks - smaller for better fit */
			.reveal pre {
				margin: 0.4em 0;
				font-size: 0.42em;
				width: 100%;
			}
			.reveal pre code {
				max-height: 420px;
				font-size: 1em;
				line-height: 1.25;
				padding: 0.6em;
			}

			/* Tables - compact */
			.reveal table {
				font-size: 0.65em;
				line-height: 1.25;
				margin: 0.4em auto;
			}
			.reveal table th,
			.reveal table td {
				padding: 0.25em 0.4em;
			}

			/* Blockquotes */
			.reveal blockquote {
				font-size: 0.7em;
				padding: 0.4em 0.8em;
				margin: 0.4em 0;
			}

			/* Slide alignment */
			.slides section {
				text-align: left;
			}
			.slides section.center {
				text-align: center;
			}

			/* Compact slide styling for content-heavy slides */
			.reveal .compact h1 {
				font-size: 1.6em;
				margin-bottom: 0.25em;
			}
			.reveal .compact h2 {
				font-size: 1.2em;
				margin-bottom: 0.25em;
			}
			.reveal .compact h3 {
				font-size: 1em;
				margin-bottom: 0.2em;
			}
			.reveal .compact p,
			.reveal .compact li {
				font-size: 0.62em;
				line-height: 1.3;
				margin-bottom: 0.25em;
			}
			.reveal .compact pre {
				font-size: 0.38em;
			}
			.reveal .compact table {
				font-size: 0.58em;
			}

			/* Custom syntax highlighting colors for Etch language */
			.reveal pre code .hljs-keyword {
				color: #F92672 !important; /* Pink - keywords like if, else, while, for, return */
			}
			.reveal pre code .hljs-type {
				color: #66D9EF !important; /* Cyan - types like int, float, void, bool */
			}
			.reveal pre code .hljs-built_in {
				color: #A6E22E !important; /* Green - built-in functions like print, rand, readFile */
			}
			.reveal pre code .hljs-title {
				color: #FD971F !important; /* Orange - function names in definitions */
			}
			.reveal pre code .hljs-string {
				color: #E6DB74 !important; /* Yellow - string literals */
			}
			.reveal pre code .hljs-number {
				color: #AE81FF !important; /* Purple - numeric literals */
			}
			.reveal pre code .hljs-literal {
				color: #AE81FF !important; /* Purple - true, false */
			}
			.reveal pre code .hljs-function > .hljs-title:last-child {
				color: #66D9EF !important; /* Orange - function names */
			}
			.reveal pre code .hljs-comment {
				color: #75715E !important; /* Gray - comments */
			}
		</style>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<!-- Slide: Title Slide -->
				<section class="center" data-markdown>
					<textarea data-template>
						# ETCH
						## Define Once, Etch Forever.

						A safety-first programming language that proves correctness at compile-timeâ€”minimalist, bold, and ready to etch your mind!
					</textarea>
				</section>

				<!-- Slide: The Problem -->
				<section class="center" data-markdown>
					<textarea data-template>
						## The Problem: Runtime Safety Bugs

						Common bugs that appear at runtime, not compile-time:

						**Memory Safety Issues:**
						- âŒ Division by zero crashes
						- âŒ Integer overflow vulnerabilities
						- âŒ Uninitialized variable bugs

						**Array and Bounds Issues:**
						- âŒ Array bounds errors
						- âŒ Buffer overflows
						- âŒ Platform-dependent behavior

						---

						## Compile-Time Safety Verification

						Etch proves safety properties at compile-time through static analysis.

						**Safety Guarantees:**
						- âœ… No division by zero
						- âœ… No integer overflow
						- âœ… No uninitialized variables
						- âœ… No array out of bounds errors

						**Additional Benefits:**
						- âœ… Dead code automatically eliminated
						- âœ… Redundant checks removed
						- âœ… Errors caught before deployment
					</textarea>
				</section>

				<!-- Slide: Language Architecture Overview -->
				<section class="center" data-markdown>
					<textarea data-template>
						## ğŸ‘‹ nuqneH, Etch!

						```etch
						fn main() -> void {
						    print("Hello, World!");
						}
						```

						ğŸ“ **C-like syntax** you already knowâ€”*simple, clean, familiar*.

						No need to learn *Klingon* to say hello! ğŸ––

						---

						## ğŸ—ï¸ Language Architecture

						**Multi-stage compilation pipeline:**

						```
						ğŸ“„ Source Code
						     â†“
						ğŸ” Frontend (Lexer â†’ Parser â†’ AST)
						     â†“
						ğŸ¨ Type Checker (Inference + Validation)
						     â†“
						ğŸ›¡ï¸ Safety Prover (Range Analysis + Symbolic Execution)
						 	 â†“
						âš¡ Comptime Executor (AST Transformation)
						                  â†“
						       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
						       â†“                     â†“
						  ğŸ’¾ Bytecode VM      ğŸ”§ C Code Generator
						```

						âœ… **Each stage adds safety guarantees**

						---

						## ğŸ“‹ The Compilation Pipeline

						**Staged transformation with safety guarantees at each step:**

						| Stage | Process | Output |
						|-------|---------|--------|
						| 1ï¸âƒ£ | **Lexer** | Token stream (frontend/lexer.nim) |
						| 2ï¸âƒ£ | **Parser** | AST (frontend/ast.nim - frontend/parser.nim) |
						| 3ï¸âƒ£ | **Type Checker** | Typed + Inferred AST (typechecker/) |
						| 4ï¸âƒ£ | **Safety Prover** | Proven AST (prover/) |
						| 5ï¸âƒ£ | **Comptime Executor** | Transformed AST (comptime.nim) |
						| 6ï¸âƒ£ | **Bytecode Generator** | Register VM bytecode (interpreter/) |
						| 7ï¸âƒ£ | **Cache** | Disk (__etch__/ directory) |
						| 8ï¸âƒ£ | **VM / C Backend** | Execution or native binary (backend/) |
					</textarea>
				</section>

				<!-- Slide: Frontend Design -->
				<section class="center" data-markdown>
					<textarea data-template>
						## ğŸ” Frontend: Lexer â†’ Parser

						**Token-based lexical analysis:**
						- ğŸ“ Position tracking for error reporting
						- âš¡ Efficient single-pass scanning
						- ğŸ¯ Source location preservation

						**Recursive descent parser:**
						- ğŸŒ³ Produces strongly-typed AST
						- ğŸ“ Expression kinds: Binary ops, Calls, Arrays, Pattern matching
						- ğŸ”€ Statement kinds: Declarations, Control flow, Assignments
						- ğŸ›¡ï¸ Syntax validation during parsing

						Note: frontend/lexer.nim and frontend/parser.nim

						---

						## ğŸŒ³ AST Node Types

						**Expression variants (20+ types):**
						- ğŸ”¢ Literals: `ekInt`, `ekFloat`, `ekString`, `ekBool`, `ekChar`
						- â• Operations: `ekBin`, `ekUn`, `ekCall`
						- ğŸ“¦ Collections: `ekArray`, `ekIndex`, `ekSlice`, `ekArrayLen`
						- ğŸ­ Pattern matching: `ekMatch`, `ekOptionSome`, `ekResultOk`
						- ğŸ—ï¸ Objects: `ekObjectLiteral`, `ekFieldAccess`, `ekNew`

						**Statement variants (15+ types):**
						- ğŸ“Œ Declarations: `skLet`, `skVar`, `skFun`, `skType`
						- ğŸ”€ Control flow: `skIf`, `skWhile`, `skFor`, `skReturn`
						- âš™ï¸ Others: `skAssign`, `skDefer`, `skComptime`

						---

						## ğŸ¯ Type System: Three-Phase Process

						**Phase 1: Type Collection** ğŸ“š
						- Gather all type definitions and global variables
						- Build forward reference table
						- Create type environment

						---

						## ğŸ¯ Type System: Three-Phase Process

						**Phase 2: Type Inference** ğŸ”®
						- Hindley-Milner style inference for generics
						- Constraint generation and unification
						- Return type inference from body
						- Generic function instantiation on demand

						---

						## ğŸ¯ Type System: Three-Phase Process

						**Phase 3: Type Validation** âœ…
						- Expression type checking (expressions.nim)
						- Statement type checking (statements.nim)
						- Full program validation

						---

						## ğŸ¨ Type Kinds

						**Primitive Types:**
						- ğŸ”¢ `tkInt`, `tkFloat`
						- âœ… `tkBool`
						- ğŸ“ `tkString`, `tkChar`
						- ğŸš« `tkVoid`

						**Composite Types:**
						- ğŸ“¦ `tkArray` - Fixed and dynamic arrays
						- ğŸ”— `tkRef` - References with generational tracking
						- ğŸ—ï¸ `tkObject` - Structured data with fields

						---

						## ğŸ¨ Type Kinds

						**Advanced Types:**
						- â“ `tkOption` - Optional values (some/none)
						- âœ¨ `tkResult` - Result types (ok/error)
						- ğŸ­ `tkGeneric` - Generic type parameters
						- ğŸ”— `tkUnion` - Sum types
					</textarea>
				</section>

				<!-- Slide: Prover Architecture -->
				<section class="center" data-markdown>
					<textarea data-template>
						## ğŸ›¡ï¸ Prover: Safety Through Analysis

						**Safety analysis through symbolic execution**

						**Core Components:**
						- ğŸ” **expression_analysis.nim**: Range propagation, expression evaluation
						- â• **binary_operations.nim**: Arithmetic operation range inference
						- ğŸ”€ **symbolic_execution.nim**: Control flow analysis
						- âš¡ **function_evaluation.nim**: Pure function compile-time execution

						**Key Concept:**
						- Track value ranges: `Info = (min: int64, max: int64)`

						Every variable has a proven range at every program point!

						---

						## ğŸ”¬ Prover: Analysis Phases

						**Phase 1: Environment Setup** ğŸ“‹
						- Initialize environment with variable declarations
						- Add all globals to environment

						---

						## ğŸ”¬ Prover: Analysis Phases

						**Phase 2: Global Analysis** ğŸŒ
						- Analyze global variable initializations
						- Track global value ranges

						---

						## ğŸ”¬ Prover: Analysis Phases

						**Phase 3: Function Analysis** ğŸ¯
						- Prove main function first
						- Analyze all reachable functions
						- Validate safety at every operation

						---

						## ğŸ”¬ Prover: Analysis Phases

						**Phase 4: Property Validation** âœ…
						- Check non-zero divisors (division/modulo)
						- Verify array bounds safety
						- Prevent integer overflow
						- Ensure variable initialization

						---

						## The Safety Prover in Action

						```etch [3|4|5]
						// âœ… Safe!
						fn main() -> void {
						    let divisor: int = rand(5, 10);         // Range: [5, 10]
						    let calculation: int = 100 / divisor;   // âœ… Safe!
						    print(calculation);
						}
						```

						**Safe Example:** divisor ranges [5, 10] â†’ division succeeds âœ…

						---

						## The Safety Prover in Action

						```etch [3|4|9-14]
						// âŒ COMPILE ERROR
						fn main() -> void {
						    let divisor: int = rand(5);             // Range: [0, 5]
						    let calculation: int = 100 / divisor;   // âŒ COMPILE ERROR
							print(calculation);
						}

						/*
						Compiling: xyz.etch
						xyz.etch:4:32: error: cannot prove divisor is non-zero in main
						3 |     let divisor: int = rand(5);             // Range: [0, 5]
						4 |     let calculation: int = 100 / divisor;   // âŒ COMPILE ERROR
														   ^
						5 |     print(calculation);
						*/
						```

						**Unsafe Example:** divisor ranges [0, 5] â†’ *COMPILE ERROR* âŒ

						Compiler tracks value ranges and proves divisor is non-zero.
					</textarea>
				</section>


				<!-- Slide: Type System & Inference -->
				<section class="center" data-markdown>
					<textarea data-template>
						## ğŸ¨ Type System & Inference

						```etch
						fn main() -> void {
						    let x: int = 42;           // Explicit type
						    let y = 3.14;              // Inferred as float
						    let name = "Etch";         // Inferred as string
						    let numbers = [1, 2, 3];   // Inferred as array[int]
						}
						```

						âœ¨ **Strong static typing**
						ğŸ”® **Smart type inference**
						âœ… **No surprises**

						Note: Types are checked at compile-time but you don't always have to write them
					</textarea>
				</section>

				<!-- Slide: Arrays with Safety Guarantees -->
				<section class="center" data-markdown>
					<textarea data-template>
						## ğŸ“¦ Arrays with Safety Guarantees

						```etch
						fn main() -> void {
						    let numbers: array[int] = [10, 20, 30, 40, 50];

						    let count: int = #numbers;              // Length operator
						    let middle: int = numbers[count / 2];   // Bounds checked
						    let slice = numbers[1:4];               // Safe slicing, inferred as array[int]
						}
						```

						- âœ… Compile-time bounds checking when possible
						- ğŸ” Runtime checks when necessary
						- ğŸ“ Clear error messages

						Note: The prover eliminates bounds checks it can prove safe
					</textarea>
				</section>

				<!-- Slide: The Prover System -->
				<section class="center" data-markdown>
					<textarea data-template>
						## ğŸ§  The Prover System

						**ğŸ“Š Range Analysis**
						- Track value ranges through program
						- ğŸ”¢ Propagate through operations
						  - [5,10] + [2,3] = [7,13]
						  - [5,10] * [2,3] = [10,30]
						  - if x < 7 then x âˆˆ [-âˆ,6]
						- âœ… Prove safety properties
						  - â— Division: denominator âˆ‰ {0}
						  - ğŸ“ˆ Overflow: result within type bounds
						  - ğŸ“¦ Array: index within [0, length)

						---

						## ğŸ§  The Prover System

						**ğŸ” Initialization Analysis**
						- Track initialization state
						- Flow-sensitive analysis
						- Ensure all paths initialize

						Note: This is the brain of Etch - mathematical proof of safety
					</textarea>
				</section>

				<!-- Slide: Compile-Time Execution -->
				<section class="center" data-markdown>
					<textarea data-template>
						## âš¡ Compile-Time Execution

						**Comptime evaluation during compilation:**

						Not macros or templatesâ€”actual code execution in the compiler.

						**Comptime Use Cases**

						- ğŸ¯ **Build-time configuration**: Different builds from same source
						- ğŸ“Š **Lookup tables**: Compute once at compile-time, use at runtime
						- ğŸš© **Feature flags**: Conditional compilation based on environment
						- ğŸ“¦ **Resource embedding**: Templates, shaders, assets in binary
						- ğŸ·ï¸ **Version information**: Embed git commit hash, build date
						- ğŸŒ **Platform-specific code**: Single codebase for multiple targets

						---

						## Comptime Basics

						```etch [6-7|9-11]
						fn square(x: int) -> int {
						    return x * x;
						}

						fn main() -> void {
							// Prints 64 during compilation
						    comptime{ print(square(8)); }

							// Evaluates to constant at compile-time
							let sq: int = comptime(square(8));
							print(sq);
						}
						```

						**Zero runtime overhead**
						- Function calls happen during compilation
						- Results embedded as constants in bytecode
						- No function call overhead at runtime

						---

						## Comptime Blocks

						```etch
						fn main() -> void {
						    comptime {
						        print("Hello from the compiler!");

						        var i: int = 0;
						        while i < 5 {
						            i = i + 1;
						        }

								print(i);
						    }

						    print("Hello from runtime!");
						}
						```

						**Compile-time output:**
						```
						Hello from the compiler!
						5
						```

						**Runtime output:**
						```
						Hello from runtime!
						```

						---

						## File Embedding

						```etch
						fn main() -> void {
						    // File read at COMPILE-TIME
						    let config: string = comptime(readFile("config.txt"));
						    print(config);  // File embedded in binary!
						}
						```

						**Embed files directly into your binary**
						- No runtime I/O
						- No missing file errors
						- Single executable deployment

						---

						## Code Injection

						```etch
						fn main() -> void {
						    comptime {
						        let env: string = readFile(".env");

						        if env == "production" {
						            inject("LOG_LEVEL", "int", 0);
						            inject("DEBUG", "bool", false);
						        } else {
						            inject("LOG_LEVEL", "int", 2);
						            inject("DEBUG", "bool", true);
						        }
						    }

						    if DEBUG { // Variable was injected!
						        print("Debug mode enabled");
						    }
						}
						```

						**Metaprogramming without macros**
						- Generate code based on compile-time conditions
					</textarea>
				</section>

				<!-- Slide: Register-Based VM Architecture -->
				<section class="center" data-markdown>
					<textarea data-template>
						## ğŸ›ï¸ Register-Based VM Architecture

						**RegVM: Lua-inspired register machine** âš¡

						| Stack VM | Register VM |
						|----------|-------------|
						| PUSH 5<br>PUSH 3<br>ADD<br>POP r0 | LoadK r0, 5<br>LoadK r1, 3<br>Add r2, r0, r1 |

						**Architecture Details:**
						- ğŸ“Ÿ 256 registers per function frame (8-bit addressing)
						- ğŸ’¾ 65536 constants per function (16-bit index)
						- ğŸ¯ 3-address instruction format (A = B op C)
						- ğŸ”§ Multiple instruction encodings: ABC, ABx, AsBx, Ax
						- âš¡ Fused instructions for common patterns

						---

						## ğŸ—ï¸ RegVM Implementation

						**Implementation modules:**
						- ğŸ® `regvm.nim`: VM core and instruction definitions (100+ opcodes)
						- ğŸ”„ `regvm_compiler.nim`: AST â†’ bytecode translation
						- â–¶ï¸ `regvm_exec.nim`: Bytecode interpreter
						- ğŸ’¾ `regvm_serialize.nim`: Bytecode caching

						---

						## ğŸ’¾ Bytecode Instructions

						**Instruction Categories:**

						ğŸ“¦ **Load/Store**
						- LoadK, Move, GetGlobal, SetGlobal

						ğŸ§® **Arithmetic**
						- Add, Sub, Mul, Div, Mod, Neg

						ğŸ”¢ **Comparison**
						- Eq, Lt, Le, Gt, Ge, Ne

						ğŸ¯ **Control Flow**
						- Jump, JumpIf, JumpIfNot, TestJump

						ğŸ“ **Function Calls**
						- Call, Return

						âš¡ **Fused Instructions (optimization!)**
						- AddAdd, MulAdd, LoadAddStore, EqStore, LtStore, IncTest

						---

						## ğŸ”€ Two Execution Modes

						**Single source, dual execution paths:**

						```
						        Etch Compiler
						             â†“
						     â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
						     â†“                â†“
						  Bytecode        C Backend
						     â†“                â†“
						 Bytecode VM      C Compiler
						     â†“                â†“
					 	 Development      Production
						```

						ğŸ”§ **Bytecode VM:** Fast iteration, debugger support, portable caching

						ğŸš€ **C Backend:** Native performance, compiler optimizations, standalone binary

						**Development workflow:** ğŸ§ª VM for rapid â†’ ğŸ“¦ C for deployment

						---

						## ğŸ’¾ Bytecode Caching

						**First run:**
						| `Source â†’ Parse â†’ Typecheck â†’ Prove â†’ Compile â†’ Cache`

						**Subsequent runs:**
						| `Source Hash Check â†’ Load Cached Bytecode â†’ Run`

						**Performance improvement:** ğŸš€ faster subsequent runs

						**Cache invalidation:**
						- âœ… Source file changed â†’ recompile
						- âœ… Source hash mismatch â†’ recompile
						- âœ… Bytecode version changed â†’ recompile

						**Implementation:**
						- ğŸ“ Cached in `__etch__/` directory
						- ğŸ” SHA-based source hashing
						- âš¡ Automatic invalidation on changes
					</textarea>
				</section>

				<!-- Slide: Bytecode VM - Fast Development -->
				<section class="center" data-markdown>
					<textarea data-template>
						## ğŸ”§ Bytecode VM - Fast Development

						**Perfect for development iteration:**

						- âš¡ Instant execution (cached)
						- ğŸ› Full debugger support
						- ğŸ“¦ Portable bytecode
						- ğŸš« No C compiler needed
						- ğŸ”— FFI to C libraries (runtime)
						- ğŸ“ Rich runtime errors

						**When to use:**
						- ğŸ’» During development
						- ğŸ“œ Scripting tasks in your app
						- ğŸ”„ Rapid prototyping
						- ğŸ§ª Running tests

						---

						## ğŸš€ C Backend - Maximum Performance

						**Compiles to clean, readable C code:**

						- ğŸ¯ Native machine code via gcc/clang
						- âš¡ Platform optimizations (-O3)
						- ğŸ”§ System calling conventions
						- ğŸ”— FFI to C libraries seamless
						- ğŸ“¦ Standalone executable

						**When to use:**
						- ğŸŒ Production deployment of bundled features
						- ğŸ’¨ Performance critical code
						- ğŸ“¤ Distribution to users
						- ğŸ”Œ Integrating with C libraries
					</textarea>
				</section>

				<!-- Slide: Implementation Language: Nim -->
				<section class="center" data-markdown>
					<textarea data-template>
						## ğŸ‘‘ Implementation Language: Nim

						**Etch compiler is written in Nim** ğŸ¯

						**Why Nim for compiler development:**
						- ğŸš€ Compiles to C â†’ Portable, fast execution
						- ğŸ Python-like syntax â†’ Readable codebase
						- ğŸ¨ Metaprogramming â†’ DSL capabilities
						- âš¡ Zero-cost abstractions â†’ Efficient compilation
						- ğŸ“š Strong standard library â†’ Less boilerplate
						- ğŸ”§ Macro system â†’ AST manipulation

						**Benefits for Etch:**
						- ğŸŒ³ Clean AST representation with algebraic types
						- ğŸ”„ Pattern matching for compiler passes
						- ğŸ”— Easy C FFI for library integration
						- â±ï¸ Fast compilation of the compiler itself (< 6 seconds)
					</textarea>
				</section>

				<!-- Slide: VSCode Debugger Integration -->
				<section class="center" data-markdown>
					<textarea data-template>
						## ğŸ› VSCode Debugger Integration

						**Full DAP (Debug Adapter Protocol) Support** âœ¨

						**Features:**
						- ğŸ”´ Set breakpoints in .etch files
						- â¯ï¸ Step through execution (step in/out/over)
						- ğŸ“Š View call stack
						- ğŸ” Inspect variables
						- ğŸ‘ï¸ Watch expressions (in progress)
						- ğŸ“Œ Conditional breakpoints (in progress)

						**Debug Server:**
						- ğŸ”Œ DAP protocol implementation (console based)
						- ğŸŒ TCP/IP communication (in progress)
						- ğŸ›ï¸ Integrated with RegVM
					</textarea>
				</section>

				<!-- Slide: Benchmark Results -->
				<section class="center" data-markdown>
					<textarea data-template>
						## ğŸ“Š Benchmark Results

						**Real benchmark data from hyperfine (generated 2025-10-22)**

						| Benchmark | C | VM | Python 3 | C vs Py | VM vs Py |
						|-----------|---|-----|----------|---------|----------|
						| ğŸ§® Arithmetic ops | 6.5ms | 115.8ms | 103.5ms | **15.9x** | 0.9x |
						| ğŸ“¦ Array ops | 6.9ms | 32.9ms | 42.8ms | **6.2x** | **1.3x** |
						| ğŸ” For loops | 10.7ms | 18.1ms | 39.4ms | **3.7x** | **2.2x** |
						| ğŸ“ Function calls | 14.2ms | 56.8ms | 32.9ms | **2.3x** | 0.6x |
						| ğŸ”¢ Math intensive | 5.0ms | 26.8ms | 31.2ms | **6.2x** | **1.2x** |
						| ğŸ’¾ Memory alloc | 2.6ms | 11.3ms | 23.6ms | **9.0x** | **2.1x** |
						| ğŸ”„ Nested loops | 6.6ms | 66.0ms | 40.3ms | **6.1x** | 0.6x |
						| ğŸ“ String ops | 13.9ms | 10.3ms | 25.2ms | **1.8x** | **2.4x** |

						**Key Takeaway:** C backend ~6x faster than Python, VM competitive for many workloads

						---

						## ğŸš€ Optimization Opportunities

						**Current Optimizations:**
						- âœ… Constant folding
						- âœ… Dead code elimination
						- âœ… Range-based check elimination
						- âš¡ Fused instructions
						- ğŸ’¾ Bytecode caching

						**Future Optimizations:**
						- ğŸ”„ Loop hoisting optimizations
						- ğŸ§® Common subexpression elimination
						- ğŸ¨ Type-specialized instructions
						- ğŸ“¦ Function inlining
						- ğŸ¯ Register coalescing

						**The compiler keeps getting faster!**
					</textarea>
				</section>

				<!-- Slide 31: Development Experience -->
				<section class="center" data-markdown>
					<textarea data-template>
						## ğŸ§ª Development Experience

						**Etch provides multiple tools for exploration:**

						**Experimentation:**
						- âš¡ Test comptime evaluation limits
						- ğŸ”¬ Understand prover range analysis
						- ğŸ“Š Profile VM vs C backend performance
						- ğŸ¨ Generate code through metaprogramming

						**Tooling:**
						- ğŸ¨ VSCode extension with syntax highlighting
						- ğŸ› DAP debugger integration
						- ğŸ“ Verbose logging for compiler internals
						- ğŸ“ˆ Performance benchmarking with `just perf`

						**Learning compiler technology:**
						- ğŸ” Inspect bytecode with verbose mode
						- ğŸ›¡ï¸ Study prover analysis output
						- ğŸ“„ Compare generated C code
						- ğŸš€ Understand optimization passes

						Note: Designed for both practical use and compiler learning
					</textarea>
				</section>

				<!-- Slide: Language Comparisons -->
				<section class="center" data-markdown>
					<textarea data-template>
						## ğŸ“Š Language Comparisons

						|  | Etch | Rust | Zig | Python | Go |
						|--|------|------|-----|--------|-----|
						| ğŸ›¡ï¸ Safety | âœ… | âœ… | âš ï¸ | âŒ | âš ï¸ |
						| ğŸ”¬ Proofs | âœ… | âš ï¸ | âŒ | âŒ | âŒ |
						| âš¡ Comptime | âœ… | âŒ | âœ… | âŒ | âŒ |
						| ğŸ“ Simple Syntax | âœ… | âš ï¸ | âœ… | âœ… | âœ… |
						| â±ï¸ Fast Compile | âœ… | âŒ | âœ… | âœ… | âœ… |
						| ğŸš« No GC | âœ… | âœ… | âœ… | âŒ | âŒ |
						| ğŸ“ Easy to Learn | âœ… | âŒ | âš ï¸ | âœ… | âœ… |

						### Etch = ğŸ›¡ï¸ Safety + ğŸ“ Simplicity + ğŸš€ Speed
					</textarea>
				</section>

				<!-- Slide: Who Is Etch For? -->
				<section class="center" data-markdown>
					<textarea data-template>
						## ğŸ¯ Who Is Etch For?

						**Perfect for:**

						- ğŸ”¬ Compiler enthusiasts exploring PL design

						- ğŸ›¡ï¸ Programmers wanting safety without complexity

						- ğŸ® Game developers needing a proper scripting runtime

						- ğŸ“š Educators teaching program verification
					</textarea>
				</section>

				<!-- Slide 36: Current Status -->
				<section class="center" data-markdown>
					<textarea data-template>
						## ğŸ¯ Current Status

						### Language Status: Active Development ğŸš§

						**What works:**
						- âœ… Core language features
						- âœ… Safety prover with range analysis
						- âœ… Compile-time execution
						- âœ… Bytecode VM with caching
						- âœ… C code generation backend
						- âœ… VSCode debugger integration
						- âœ… Test framework
						- âœ… Performance benchmarking

						**Production ready?** Not yet! âš ï¸

						**Great for:** ğŸ§ª Experiments Â· ğŸ“š Learning Â· ğŸ”¬ Research

						Note: Etch is actively evolving
					</textarea>
				</section>

				<!-- Slide : Roadmap -->
				<section class="center" data-markdown>
					<textarea data-template>
						## ğŸ—ºï¸ Roadmap

						**Phase 1: Bytecode optimization** ğŸ’¾
						- ğŸ”§ Re-enable optimizer
						- ğŸ›¡ï¸ Integrate prover data
						- ğŸ“Š Enhanced constant folding

						---

						## ğŸ—ºï¸ Roadmap

						**Phase 2: Instruction improvements** ğŸ¯
						- ğŸ”– Jump target tables
						- ğŸ“ ARG instructions
						- ğŸ”„ Reversed operations

						---

						## ğŸ—ºï¸ Roadmap

						**Phase 3: Advanced optimizations** ğŸš€
						- ğŸ”¬ Peephole optimization
						- ğŸ§® Common subexpression elimination
						- ğŸ”„ Loop optimizations

						---

						## ğŸ—ºï¸ Roadmap

						**Phase 4: Type-aware optimization** ğŸ¨
						- ğŸ¯ Static type specialization
						- ğŸ“¦ Function inlining

						Note: There's a detailed improvement plan in the repo
					</textarea>
				</section>

				<!-- Slide: Live Demo Setup -->
				<section class="center" data-markdown>
					<textarea data-template>
						## Let's see Etch in action! ğŸ¬

						**Demos:**
						1. ğŸ›¡ï¸ Safety proofs catching bugs
						2. âš¡ Comptime execution
						3. ğŸ› Debugger in VSCode
						4. ğŸ“Š Performance comparison
						5. ğŸ”§ C backend code generation
					</textarea>
				</section>

				<!-- Slide: Questions? -->
				<section class="center" data-markdown>
					<textarea data-template>
						# Questions?

						## "Define once, Etch forever."

						### Thank you! ğŸš€
					</textarea>
				</section>

			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script src="plugin/highlight/etch.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,
				slideNumber: true,
				showNotes: false,
				center: false,
				transition: 'slide',

				highlight: {
					beforeHighlight: (hljs) => {
						hljs.registerLanguage('etch', etchLang);
						hljs.registerLanguage('etchlang', etchLang);
					}
				},

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>